/**
 * @fileoverview Style Dictionary Configuration
 * Transforms design tokens from JSON to CSS, TypeScript, and SCSS formats
 * 
 * @see DESIGN_SYSTEM.md#design-tokens
 */

/**
 * Custom transform to convert px values to rem
 * @param {Object} token - Token object
 * @returns {string} Transformed value
 */
function pxToRem(token) {
  const baseFont = 16;
  if (typeof token.value === 'string' && token.value.endsWith('px')) {
    const pxValue = parseFloat(token.value);
    return `${pxValue / baseFont}rem`;
  }
  return token.value;
}

/**
 * Custom transform to generate CSS custom property names
 * @param {Object} token - Token object
 * @returns {string} CSS variable name
 */
function cssVariableName(token) {
  return `--harmony-${token.path.join('-')}`;
}

/**
 * Custom transform to generate TypeScript constant names
 * @param {Object} token - Token object
 * @returns {string} TypeScript constant name
 */
function tsConstantName(token) {
  return token.path.map(part => 
    part.toUpperCase().replace(/-/g, '_')
  ).join('_');
}

/**
 * Custom transform to generate SCSS variable names
 * @param {Object} token - Token object
 * @returns {string} SCSS variable name
 */
function scssVariableName(token) {
  return `$harmony-${token.path.join('-')}`;
}

/**
 * Custom format for CSS custom properties
 * @param {Object} dictionary - Token dictionary
 * @returns {string} CSS output
 */
function cssFormat(dictionary) {
  const tokens = dictionary.allTokens;
  let output = '/**\n * Harmony Design System Tokens\n * Generated by Style Dictionary\n * DO NOT EDIT DIRECTLY\n */\n\n';
  output += ':root {\n';
  
  tokens.forEach(token => {
    const name = cssVariableName(token);
    const value = token.attributes?.cssValue || token.value;
    output += `  ${name}: ${value};\n`;
  });
  
  output += '}\n';
  return output;
}

/**
 * Custom format for TypeScript constants
 * @param {Object} dictionary - Token dictionary
 * @returns {string} TypeScript output
 */
function tsFormat(dictionary) {
  const tokens = dictionary.allTokens;
  let output = '/**\n * Harmony Design System Tokens\n * Generated by Style Dictionary\n * DO NOT EDIT DIRECTLY\n */\n\n';
  
  // Group tokens by category
  const categories = {};
  tokens.forEach(token => {
    const category = token.path[0];
    if (!categories[category]) {
      categories[category] = [];
    }
    categories[category].push(token);
  });
  
  // Generate TypeScript interfaces and constants
  Object.keys(categories).forEach(category => {
    const categoryTokens = categories[category];
    const interfaceName = category.charAt(0).toUpperCase() + category.slice(1) + 'Tokens';
    
    output += `export interface ${interfaceName} {\n`;
    categoryTokens.forEach(token => {
      const propName = token.path.slice(1).join('_');
      output += `  ${propName}: string;\n`;
    });
    output += '}\n\n';
    
    output += `export const ${category}Tokens: ${interfaceName} = {\n`;
    categoryTokens.forEach(token => {
      const propName = token.path.slice(1).join('_');
      const value = JSON.stringify(token.value);
      output += `  ${propName}: ${value},\n`;
    });
    output += '};\n\n';
  });
  
  return output;
}

/**
 * Custom format for SCSS variables
 * @param {Object} dictionary - Token dictionary
 * @returns {string} SCSS output
 */
function scssFormat(dictionary) {
  const tokens = dictionary.allTokens;
  let output = '/**\n * Harmony Design System Tokens\n * Generated by Style Dictionary\n * DO NOT EDIT DIRECTLY\n */\n\n';
  
  tokens.forEach(token => {
    const name = scssVariableName(token);
    const value = token.attributes?.scssValue || token.value;
    output += `${name}: ${value};\n`;
  });
  
  return output;
}

/**
 * Style Dictionary configuration object
 */
export const config = {
  source: ['./tokens/design-tokens.json'],
  
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: './tokens/generated/',
      files: [{
        destination: 'tokens.css',
        format: 'css/variables',
        options: {
          outputReferences: true
        }
      }]
    },
    
    typescript: {
      transformGroup: 'js',
      buildPath: './tokens/generated/',
      files: [{
        destination: 'tokens.ts',
        format: 'typescript/es6-declarations',
        options: {
          outputReferences: false
        }
      }]
    },
    
    scss: {
      transformGroup: 'scss',
      buildPath: './tokens/generated/',
      files: [{
        destination: 'tokens.scss',
        format: 'scss/variables',
        options: {
          outputReferences: true
        }
      }]
    },
    
    json: {
      transformGroup: 'js',
      buildPath: './tokens/generated/',
      files: [{
        destination: 'tokens.json',
        format: 'json/flat'
      }]
    }
  }
};

/**
 * Custom transforms registry
 */
export const transforms = {
  'size/pxToRem': {
    type: 'value',
    matcher: (token) => token.attributes?.category === 'size',
    transformer: pxToRem
  },
  
  'name/css': {
    type: 'name',
    transformer: cssVariableName
  },
  
  'name/ts': {
    type: 'name',
    transformer: tsConstantName
  },
  
  'name/scss': {
    type: 'name',
    transformer: scssVariableName
  }
};

/**
 * Custom formats registry
 */
export const formats = {
  'css/variables': cssFormat,
  'typescript/es6-declarations': tsFormat,
  'scss/variables': scssFormat
};