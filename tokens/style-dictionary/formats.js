/**
 * @fileoverview Custom Style Dictionary Formats
 * Provides output formatters for different target platforms
 * 
 * @see DESIGN_SYSTEM.md#design-tokens
 */

/**
 * Format tokens as CSS custom properties
 * @param {Object} dictionary - Token dictionary
 * @param {Object} options - Format options
 * @returns {string} CSS output
 */
export function cssVariables(dictionary, options = {}) {
  const { selector = ':root', outputReferences = true } = options;
  const tokens = dictionary.allTokens;
  
  let output = '/**\n';
  output += ' * Harmony Design System Tokens\n';
  output += ' * Generated by Style Dictionary\n';
  output += ' * DO NOT EDIT DIRECTLY\n';
  output += ' * @see DESIGN_SYSTEM.md#design-tokens\n';
  output += ' */\n\n';
  
  output += `${selector} {\n`;
  
  tokens.forEach(token => {
    const name = `--harmony-${token.path.join('-')}`;
    const value = token.value;
    output += `  ${name}: ${value};\n`;
  });
  
  output += '}\n';
  
  return output;
}

/**
 * Format tokens as TypeScript ES6 declarations
 * @param {Object} dictionary - Token dictionary
 * @param {Object} options - Format options
 * @returns {string} TypeScript output
 */
export function typescriptDeclarations(dictionary, options = {}) {
  const tokens = dictionary.allTokens;
  
  let output = '/**\n';
  output += ' * Harmony Design System Tokens\n';
  output += ' * Generated by Style Dictionary\n';
  output += ' * DO NOT EDIT DIRECTLY\n';
  output += ' * @see DESIGN_SYSTEM.md#design-tokens\n';
  output += ' */\n\n';
  
  // Group tokens by category
  const categories = {};
  tokens.forEach(token => {
    const category = token.path[0];
    if (!categories[category]) {
      categories[category] = [];
    }
    categories[category].push(token);
  });
  
  // Generate interfaces and constants for each category
  Object.keys(categories).sort().forEach(category => {
    const categoryTokens = categories[category];
    const typeName = category.charAt(0).toUpperCase() + category.slice(1) + 'Tokens';
    
    output += `export interface ${typeName} {\n`;
    categoryTokens.forEach(token => {
      const propName = token.path.slice(1).join('_').replace(/-/g, '_');
      const comment = token.attributes?.description || '';
      if (comment) {
        output += `  /** ${comment} */\n`;
      }
      output += `  readonly ${propName}: string;\n`;
    });
    output += '}\n\n';
    
    output += `export const ${category}: ${typeName} = {\n`;
    categoryTokens.forEach(token => {
      const propName = token.path.slice(1).join('_').replace(/-/g, '_');
      const value = JSON.stringify(token.value);
      output += `  ${propName}: ${value},\n`;
    });
    output += '} as const;\n\n';
  });
  
  // Generate unified export
  output += 'export const tokens = {\n';
  Object.keys(categories).sort().forEach(category => {
    output += `  ${category},\n`;
  });
  output += '} as const;\n';
  
  return output;
}

/**
 * Format tokens as SCSS variables
 * @param {Object} dictionary - Token dictionary
 * @param {Object} options - Format options
 * @returns {string} SCSS output
 */
export function scssVariables(dictionary, options = {}) {
  const tokens = dictionary.allTokens;
  
  let output = '/**\n';
  output += ' * Harmony Design System Tokens\n';
  output += ' * Generated by Style Dictionary\n';
  output += ' * DO NOT EDIT DIRECTLY\n';
  output += ' * @see DESIGN_SYSTEM.md#design-tokens\n';
  output += ' */\n\n';
  
  tokens.forEach(token => {
    const name = `$harmony-${token.path.join('-')}`;
    const value = token.value;
    const comment = token.attributes?.description || '';
    
    if (comment) {
      output += `// ${comment}\n`;
    }
    output += `${name}: ${value};\n`;
  });
  
  return output;
}

/**
 * Format tokens as flat JSON
 * @param {Object} dictionary - Token dictionary
 * @param {Object} options - Format options
 * @returns {string} JSON output
 */
export function jsonFlat(dictionary, options = {}) {
  const tokens = dictionary.allTokens;
  const flat = {};
  
  tokens.forEach(token => {
    const key = token.path.join('.');
    flat[key] = {
      value: token.value,
      type: token.type,
      attributes: token.attributes
    };
  });
  
  return JSON.stringify(flat, null, 2);
}

/**
 * Format tokens as JavaScript ES6 module
 * @param {Object} dictionary - Token dictionary
 * @param {Object} options - Format options
 * @returns {string} JavaScript output
 */
export function javascriptModule(dictionary, options = {}) {
  const tokens = dictionary.allTokens;
  
  let output = '/**\n';
  output += ' * Harmony Design System Tokens\n';
  output += ' * Generated by Style Dictionary\n';
  output += ' * DO NOT EDIT DIRECTLY\n';
  output += ' * @see DESIGN_SYSTEM.md#design-tokens\n';
  output += ' */\n\n';
  
  // Group tokens by category
  const categories = {};
  tokens.forEach(token => {
    const category = token.path[0];
    if (!categories[category]) {
      categories[category] = [];
    }
    categories[category].push(token);
  });
  
  // Generate exports for each category
  Object.keys(categories).sort().forEach(category => {
    const categoryTokens = categories[category];
    
    output += `export const ${category} = {\n`;
    categoryTokens.forEach(token => {
      const propName = token.path.slice(1).join('_').replace(/-/g, '_');
      const value = JSON.stringify(token.value);
      output += `  ${propName}: ${value},\n`;
    });
    output += '};\n\n';
  });
  
  // Generate unified export
  output += 'export const tokens = {\n';
  Object.keys(categories).sort().forEach(category => {
    output += `  ${category},\n`;
  });
  output += '};\n';
  
  return output;
}

/**
 * Registry of all custom formats
 */
export const formatRegistry = {
  'css/variables': cssVariables,
  'typescript/es6-declarations': typescriptDeclarations,
  'scss/variables': scssVariables,
  'json/flat': jsonFlat,
  'javascript/es6': javascriptModule
};