#!/usr/bin/env python3
"""
Rust Struct Generator from JSON Schema

Generates Rust struct definitions from JSON Schema files.
Part of the schema-driven codegen pipeline.

Usage:
    python rust-struct-generator.py <schema-file> [output-file]
    python rust-struct-generator.py schemas/domain.schema.json
"""

import json
import sys
import os
from pathlib import Path
from typing import Dict, List, Any, Optional


class RustStructGenerator:
    """Generates Rust structs from JSON Schema definitions."""

    # JSON Schema type to Rust type mapping
    TYPE_MAP = {
        "string": "String",
        "integer": "i64",
        "number": "f64",
        "boolean": "bool",
        "array": "Vec<{}>",
        "object": "serde_json::Value",  # Generic fallback
    }

    def __init__(self, schema: Dict[str, Any]):
        """
        Initialize generator with a JSON schema.

        Args:
            schema: Parsed JSON schema dictionary
        """
        self.schema = schema
        self.generated_structs: List[str] = []
        self.imports: set = {
            "use serde::{Deserialize, Serialize};",
        }

    def generate(self) -> str:
        """
        Generate Rust code from the schema.

        Returns:
            Complete Rust source code as string
        """
        # Generate main struct from root schema
        if "title" in self.schema:
            struct_name = self._to_pascal_case(self.schema["title"])
            self._generate_struct(struct_name, self.schema)

        # Generate any referenced definitions
        if "definitions" in self.schema or "$defs" in self.schema:
            defs = self.schema.get("definitions") or self.schema.get("$defs")
            for def_name, def_schema in defs.items():
                struct_name = self._to_pascal_case(def_name)
                self._generate_struct(struct_name, def_schema)

        # Build final output
        output_parts = [
            "// Generated by rust-struct-generator.py",
            "// DO NOT EDIT MANUALLY - regenerate from schema",
            "",
        ]

        # Add imports
        output_parts.extend(sorted(self.imports))
        output_parts.append("")

        # Add all generated structs
        output_parts.extend(self.generated_structs)

        return "\n".join(output_parts)

    def _generate_struct(self, name: str, schema: Dict[str, Any]) -> None:
        """
        Generate a single Rust struct definition.

        Args:
            name: Struct name in PascalCase
            schema: JSON schema for this struct
        """
        lines = []

        # Add documentation from description
        if "description" in schema:
            lines.append(f"/// {schema['description']}")

        # Add derive macros
        lines.append("#[derive(Debug, Clone, Serialize, Deserialize)]")

        # Handle serde rename rules
        if "properties" in schema:
            lines.append('#[serde(rename_all = "camelCase")]')

        # Struct declaration
        lines.append(f"pub struct {name} {{")

        # Generate fields
        if "properties" in schema:
            required_fields = set(schema.get("required", []))

            for prop_name, prop_schema in schema["properties"].items():
                field_lines = self._generate_field(
                    prop_name, prop_schema, prop_name in required_fields
                )
                lines.extend(field_lines)

        lines.append("}")
        lines.append("")  # Blank line after struct

        self.generated_structs.append("\n".join(lines))

    def _generate_field(
        self, name: str, schema: Dict[str, Any], required: bool
    ) -> List[str]:
        """
        Generate field definition with documentation and attributes.

        Args:
            name: Field name (will be converted to snake_case)
            schema: JSON schema for this field
            required: Whether field is required

        Returns:
            List of lines for this field
        """
        lines = []

        # Add field documentation
        if "description" in schema:
            lines.append(f"    /// {schema['description']}")

        # Handle rename if needed
        snake_name = self._to_snake_case(name)
        if snake_name != name:
            lines.append(f'    #[serde(rename = "{name}")]')

        # Handle optional fields
        if not required:
            lines.append('    #[serde(skip_serializing_if = "Option::is_none")]')

        # Determine Rust type
        rust_type = self._get_rust_type(schema)

        # Wrap in Option if not required
        if not required:
            rust_type = f"Option<{rust_type}>"

        lines.append(f"    pub {snake_name}: {rust_type},")
        lines.append("")  # Blank line between fields

        return lines

    def _get_rust_type(self, schema: Dict[str, Any]) -> str:
        """
        Convert JSON Schema type to Rust type.

        Args:
            schema: JSON schema type definition

        Returns:
            Rust type as string
        """
        # Handle $ref
        if "$ref" in schema:
            ref_path = schema["$ref"]
            # Extract type name from #/definitions/TypeName or #/$defs/TypeName
            if ref_path.startswith("#/"):
                type_name = ref_path.split("/")[-1]
                return self._to_pascal_case(type_name)

        # Handle enum
        if "enum" in schema:
            # For simple enums, use String and validate at runtime
            return "String"

        # Handle array
        if schema.get("type") == "array":
            if "items" in schema:
                item_type = self._get_rust_type(schema["items"])
                return f"Vec<{item_type}>"
            return "Vec<serde_json::Value>"

        # Handle oneOf/anyOf - use serde_json::Value for flexibility
        if "oneOf" in schema or "anyOf" in schema:
            self.imports.add("use serde_json;")
            return "serde_json::Value"

        # Handle basic types
        json_type = schema.get("type", "object")
        return self.TYPE_MAP.get(json_type, "serde_json::Value")

    @staticmethod
    def _to_pascal_case(s: str) -> str:
        """Convert string to PascalCase."""
        # Handle already PascalCase
        if s[0].isupper() and "_" not in s and "-" not in s:
            return s

        # Split on underscores, hyphens, or spaces
        words = s.replace("-", "_").replace(" ", "_").split("_")
        return "".join(word.capitalize() for word in words if word)

    @staticmethod
    def _to_snake_case(s: str) -> str:
        """Convert string to snake_case."""
        # Handle camelCase
        result = []
        for i, char in enumerate(s):
            if char.isupper() and i > 0:
                result.append("_")
                result.append(char.lower())
            else:
                result.append(char.lower())
        return "".join(result)


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python rust-struct-generator.py <schema-file> [output-file]")
        print("\nExample:")
        print("  python rust-struct-generator.py schemas/domain.schema.json")
        print(
            "  python rust-struct-generator.py schemas/domain.schema.json src/domain.rs"
        )
        sys.exit(1)

    schema_path = Path(sys.argv[1])
    if not schema_path.exists():
        print(f"Error: Schema file not found: {schema_path}")
        sys.exit(1)

    # Read and parse schema
    try:
        with open(schema_path, "r", encoding="utf-8") as f:
            schema = json.load(f)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON in schema file: {e}")
        sys.exit(1)

    # Generate Rust code
    generator = RustStructGenerator(schema)
    rust_code = generator.generate()

    # Output to file or stdout
    if len(sys.argv) >= 3:
        output_path = Path(sys.argv[2])
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(rust_code)
        print(f"Generated Rust code written to: {output_path}")
    else:
        print(rust_code)


if __name__ == "__main__":
    main()